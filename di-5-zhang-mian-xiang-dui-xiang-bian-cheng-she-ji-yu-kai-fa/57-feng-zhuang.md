## 本节重点

* 掌握封装，封装与扩展性
* 掌握property

> **本节时长需控制在35分钟内**

### 引子

从封装本身的意思去理解，封装就好像是拿来一个麻袋，把小猫，小狗，小王八，还有alex一起装进麻袋，然后把麻袋封上口子。照这种逻辑看，封装=‘隐藏’，这种理解是相当片面的

### 先看如何隐藏

在python中用双下划线开头的方式将属性隐藏起来（设置成私有的）

```py
#其实这仅仅这是一种变形操作
#类中所有双下划线开头的名称如__x都会自动变形成：_类名__x的形式：

class A:
    __N=0 #类的数据属性就应该是共享的,但是语法上是可以把类的数据属性设置成私有的如__N,会变形为_A__N
    def __init__(self):
        self.__X=10 #变形为self._A__X
    def __foo(self): #变形为_A__foo
        print('from A')
    def bar(self):
        self.__foo() #只有在类内部才可以通过__foo的形式访问到.

#A._A__N是可以访问到的，即这种操作并不是严格意义上的限制外部访问，仅仅只是一种语法意义上的变形
```

**这种自动变形的特点：**

1. 类中定义的\_\_x只能在内部使用，如self.\_\_x，引用的就是变形的结果。
2. 这种变形其实正是针对外部的变形，在外部是无法通过\_\_x这个名字访问到的。
3. 在子类定义的\_\_x不会覆盖在父类定义的\_\_x，因为子类中变形成了：\_子类名\_\_x,而父类中变形成了：\_父类名\_\_x，即双下滑线开头的属性在继承给子类时，子类是无法覆盖的。

**这种变形需要注意的问题是：**

1、这种机制也并没有真正意义上限制我们从外部直接访问属性，知道了类名和属性名就可以拼出名字：\_类名\_\_属性，然后就可以访问了，如a.\_A\_\_N

2、变形的过程只在类的定义是发生一次,在定义后的赋值操作，不会变形

![](/assets/封装1.png)  
3、在继承中，父类如果不想让子类覆盖自己的方法，可以将方法定义为私有的

```py
#正常情况
>>> class A:
...     def fa(self):
...         print('from A')
...     def test(self):
...         self.fa()
... 
>>> class B(A):
...     def fa(self):
...         print('from B')
... 
>>> b=B()
>>> b.test()
from B
 

#把fa定义成私有的，即__fa
>>> class A:
...     def __fa(self): #在定义时就变形为_A__fa
...         print('from A')
...     def test(self):
...         self.__fa() #只会与自己所在的类为准,即调用_A__fa
... 
>>> class B(A):
...     def __fa(self):
...         print('from B')
... 
>>> b=B()
>>> b.test()
from A
```

### 封装不是单纯意义的隐藏

### 特性（property）

### 封装与扩展性



